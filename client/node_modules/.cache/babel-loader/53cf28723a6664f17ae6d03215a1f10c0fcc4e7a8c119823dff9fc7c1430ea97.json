{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\RK\\\\Downloads\\\\opentalk_voice_app\\\\client\\\\src\\\\pages\\\\Call.js\",\n  _s = $RefreshSig$();\n// import React, { useEffect, useRef, useState } from 'react';\n// import socket from '../socket'; // <-- yahan se lo, naya mat banao\n\n// let pc;\n\n// export default function Call1({ user }) {\n//   const remoteAudio = useRef();\n//   const [inCall, setInCall] = useState(false);\n//   const [partner, setPartner] = useState(null);\n//   const [roomId, setRoomId] = useState(null);\n\n//   useEffect(() => {\n//     // mark online\n//     socket.emit('iamonline', { userId: user.id });\n\n//     // if a room was passed via query param (Connect navigates with ?room=...), start as initiator\n//     const params = new URLSearchParams(window.location.search);\n//     const roomFromUrl = params.get('room');\n//     if (roomFromUrl) {\n//       setRoomId(roomFromUrl);\n//       // startPeer as initiator (true). errors logged.\n//       startPeer(roomFromUrl).catch(err => console.error('startPeer error:', err));\n//     }\n\n//     const onMatched = async ({ roomId: rId, partner: p }) => {\n//       setPartner(p);\n//       setRoomId(rId);\n//       await startPeer(rId);\n//     };\n\n//     const onOffer = async (offer) => {\n//       // ensure peer connection exists for answer\n//       if (!pc) await startPeer(roomId, false);\n//       // set remote and create/send answer\n//       await pc.setRemoteDescription(offer);\n//       const answer = await pc.createAnswer();\n//       await pc.setLocalDescription(answer);\n//       socket.emit('answer', { roomId, answer });\n//     };\n\n//     const onAnswer = async (answer) => {\n//       if (pc) await pc.setRemoteDescription(answer);\n//     };\n\n//     const onIceCandidate = async (candidate) => {\n//       if (pc) await pc.addIceCandidate(candidate);\n//     };\n\n//     socket.on('matched', onMatched);\n//     socket.on('offer', onOffer);\n//     socket.on('answer', onAnswer);\n//     socket.on('ice-candidate', onIceCandidate);\n\n//     return () => {\n//       // don't disconnect shared socket here; just cleanup listeners and peer\n//       try {\n//         if (pc) {\n//           pc.close();\n//           pc = null;\n//         }\n//       } catch (e) {\n//         console.warn('pc close error', e);\n//       }\n\n//       socket.off('matched', onMatched);\n//       socket.off('offer', onOffer);\n//       socket.off('answer', onAnswer);\n//       socket.off('ice-candidate', onIceCandidate);\n\n//       // remove unload handler\n//       window.onbeforeunload = null;\n//     };\n//   }, []);\n\n//   const startPeer = async (rId, initiator = true) => {\n//     // create RTCPeerConnection\n//     pc = new RTCPeerConnection();\n//     setInCall(true);\n\n//     // get only audio\n//     let stream;\n//     try {\n//       stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n//     } catch (err) {\n//       console.error('getUserMedia failed', err);\n//       setInCall(false);\n//       return;\n//     }\n\n//     stream.getTracks().forEach(track => pc.addTrack(track, stream));\n\n//     pc.ontrack = (e) => {\n//       if (remoteAudio.current) {\n//         remoteAudio.current.srcObject = e.streams[0];\n//       }\n//     };\n\n//     pc.onicecandidate = (event) => {\n//       if (event.candidate) {\n//         socket.emit('ice-candidate', { roomId: rId, candidate: event.candidate });\n//       }\n//     };\n\n//     if (initiator) {\n//       const offer = await pc.createOffer();\n//       await pc.setLocalDescription(offer);\n//       socket.emit('offer', { roomId: rId, offer });\n//     }\n\n//     // ensure other tab close / reload notifies server\n//     window.onbeforeunload = () => {\n//       try {\n//         socket.emit('leave', { userId: user.id, roomId: rId });\n//       } catch (e) { /* ignore */ }\n//     };\n//   };\n\n//   const leave = () => {\n//     if (pc) {\n//       try { pc.close(); } catch (e) { /* ignore */ }\n//       pc = null;\n//     }\n//     if (roomId) {\n//       socket.emit('leave', { userId: user.id, roomId });\n//     }\n//     setInCall(false);\n//     setPartner(null);\n//     setRoomId(null);\n//     // clear unload handler\n//     window.onbeforeunload = null;\n//   };\n\n//   return (\n//     <div>\n//       <h2>Call</h2>\n//       {partner && <p>Partner: {partner.username}</p>}\n//       <audio ref={remoteAudio} autoPlay />\n//       {!inCall && <p>Waiting to join call...</p>}\n//       {inCall && <button onClick={leave}>Disconnect</button>}\n//     </div>\n//   );\n// }\nimport React, { useEffect, useRef, useState } from 'react';\nimport socket from '../socket';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nlet pc;\nexport default function Call1({\n  user\n}) {\n  _s();\n  const remoteAudio = useRef();\n  const [inCall, setInCall] = useState(false);\n  const [partner, setPartner] = useState(null);\n  const [roomId, setRoomId] = useState(null);\n  useEffect(() => {\n    socket.emit('iamonline', {\n      userId: user.id\n    });\n    const onMatched = async ({\n      roomId: rId,\n      partner: p\n    }) => {\n      setPartner(p);\n      setRoomId(rId);\n      await startPeer(rId);\n    };\n    const onOffer = async offer => {\n      if (!pc) await startPeer(roomId, false);\n      await pc.setRemoteDescription(offer);\n      const answer = await pc.createAnswer();\n      await pc.setLocalDescription(answer);\n      socket.emit('answer', {\n        roomId,\n        answer\n      });\n    };\n    const onAnswer = async answer => {\n      if (pc) await pc.setRemoteDescription(answer);\n    };\n    const onIceCandidate = async candidate => {\n      if (pc) await pc.addIceCandidate(candidate);\n    };\n    socket.on('matched', onMatched);\n    socket.on('offer', onOffer);\n    socket.on('answer', onAnswer);\n    socket.on('ice-candidate', onIceCandidate);\n    return () => {\n      if (pc) pc.close();\n      pc = null;\n      socket.off('matched', onMatched);\n      socket.off('offer', onOffer);\n      socket.off('answer', onAnswer);\n      socket.off('ice-candidate', onIceCandidate);\n      window.onbeforeunload = null;\n    };\n  }, []);\n  const startPeer = async (rId, initiator = true) => {\n    pc = new RTCPeerConnection();\n    setInCall(true);\n    let stream;\n    try {\n      stream = await navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: false\n      });\n    } catch (err) {\n      console.error('getUserMedia failed', err);\n      setInCall(false);\n      return;\n    }\n    stream.getTracks().forEach(track => pc.addTrack(track, stream));\n    pc.ontrack = e => {\n      if (remoteAudio.current) remoteAudio.current.srcObject = e.streams[0];\n    };\n    pc.onicecandidate = event => {\n      if (event.candidate) {\n        socket.emit('ice-candidate', {\n          roomId: rId,\n          candidate: event.candidate\n        });\n      }\n    };\n    if (initiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      socket.emit('offer', {\n        roomId: rId,\n        offer\n      });\n    }\n    window.onbeforeunload = () => {\n      socket.emit('leave', {\n        userId: user.id,\n        roomId: rId\n      });\n    };\n  };\n  const leave = () => {\n    if (pc) pc.close();\n    pc = null;\n    if (roomId) socket.emit('leave', {\n      userId: user.id,\n      roomId\n    });\n    setInCall(false);\n    setPartner(null);\n    setRoomId(null);\n    window.onbeforeunload = null;\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: [/*#__PURE__*/_jsxDEV(\"h2\", {\n      children: \"Call\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 243,\n      columnNumber: 7\n    }, this), partner && /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [\"Partner: \", partner.username]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 244,\n      columnNumber: 19\n    }, this), /*#__PURE__*/_jsxDEV(\"audio\", {\n      ref: remoteAudio,\n      autoPlay: true\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 245,\n      columnNumber: 7\n    }, this), !inCall && /*#__PURE__*/_jsxDEV(\"p\", {\n      children: \"Waiting to join call...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 246,\n      columnNumber: 19\n    }, this), inCall && /*#__PURE__*/_jsxDEV(\"button\", {\n      onClick: leave,\n      children: \"Disconnect\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 247,\n      columnNumber: 18\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 242,\n    columnNumber: 5\n  }, this);\n}\n_s(Call1, \"p4U1AnJnX05CUqdd6AjFlh1bzUA=\");\n_c = Call1;\nvar _c;\n$RefreshReg$(_c, \"Call1\");","map":{"version":3,"names":["React","useEffect","useRef","useState","socket","jsxDEV","_jsxDEV","pc","Call1","user","_s","remoteAudio","inCall","setInCall","partner","setPartner","roomId","setRoomId","emit","userId","id","onMatched","rId","p","startPeer","onOffer","offer","setRemoteDescription","answer","createAnswer","setLocalDescription","onAnswer","onIceCandidate","candidate","addIceCandidate","on","close","off","window","onbeforeunload","initiator","RTCPeerConnection","stream","navigator","mediaDevices","getUserMedia","audio","video","err","console","error","getTracks","forEach","track","addTrack","ontrack","e","current","srcObject","streams","onicecandidate","event","createOffer","leave","children","fileName","_jsxFileName","lineNumber","columnNumber","username","ref","autoPlay","onClick","_c","$RefreshReg$"],"sources":["C:/Users/RK/Downloads/opentalk_voice_app/client/src/pages/Call.js"],"sourcesContent":["// import React, { useEffect, useRef, useState } from 'react';\n// import socket from '../socket'; // <-- yahan se lo, naya mat banao\n\n// let pc;\n\n// export default function Call1({ user }) {\n//   const remoteAudio = useRef();\n//   const [inCall, setInCall] = useState(false);\n//   const [partner, setPartner] = useState(null);\n//   const [roomId, setRoomId] = useState(null);\n\n//   useEffect(() => {\n//     // mark online\n//     socket.emit('iamonline', { userId: user.id });\n\n//     // if a room was passed via query param (Connect navigates with ?room=...), start as initiator\n//     const params = new URLSearchParams(window.location.search);\n//     const roomFromUrl = params.get('room');\n//     if (roomFromUrl) {\n//       setRoomId(roomFromUrl);\n//       // startPeer as initiator (true). errors logged.\n//       startPeer(roomFromUrl).catch(err => console.error('startPeer error:', err));\n//     }\n\n//     const onMatched = async ({ roomId: rId, partner: p }) => {\n//       setPartner(p);\n//       setRoomId(rId);\n//       await startPeer(rId);\n//     };\n\n//     const onOffer = async (offer) => {\n//       // ensure peer connection exists for answer\n//       if (!pc) await startPeer(roomId, false);\n//       // set remote and create/send answer\n//       await pc.setRemoteDescription(offer);\n//       const answer = await pc.createAnswer();\n//       await pc.setLocalDescription(answer);\n//       socket.emit('answer', { roomId, answer });\n//     };\n\n//     const onAnswer = async (answer) => {\n//       if (pc) await pc.setRemoteDescription(answer);\n//     };\n\n//     const onIceCandidate = async (candidate) => {\n//       if (pc) await pc.addIceCandidate(candidate);\n//     };\n\n//     socket.on('matched', onMatched);\n//     socket.on('offer', onOffer);\n//     socket.on('answer', onAnswer);\n//     socket.on('ice-candidate', onIceCandidate);\n\n//     return () => {\n//       // don't disconnect shared socket here; just cleanup listeners and peer\n//       try {\n//         if (pc) {\n//           pc.close();\n//           pc = null;\n//         }\n//       } catch (e) {\n//         console.warn('pc close error', e);\n//       }\n\n//       socket.off('matched', onMatched);\n//       socket.off('offer', onOffer);\n//       socket.off('answer', onAnswer);\n//       socket.off('ice-candidate', onIceCandidate);\n\n//       // remove unload handler\n//       window.onbeforeunload = null;\n//     };\n//   }, []);\n\n//   const startPeer = async (rId, initiator = true) => {\n//     // create RTCPeerConnection\n//     pc = new RTCPeerConnection();\n//     setInCall(true);\n\n//     // get only audio\n//     let stream;\n//     try {\n//       stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n//     } catch (err) {\n//       console.error('getUserMedia failed', err);\n//       setInCall(false);\n//       return;\n//     }\n\n//     stream.getTracks().forEach(track => pc.addTrack(track, stream));\n\n//     pc.ontrack = (e) => {\n//       if (remoteAudio.current) {\n//         remoteAudio.current.srcObject = e.streams[0];\n//       }\n//     };\n\n//     pc.onicecandidate = (event) => {\n//       if (event.candidate) {\n//         socket.emit('ice-candidate', { roomId: rId, candidate: event.candidate });\n//       }\n//     };\n\n//     if (initiator) {\n//       const offer = await pc.createOffer();\n//       await pc.setLocalDescription(offer);\n//       socket.emit('offer', { roomId: rId, offer });\n//     }\n\n//     // ensure other tab close / reload notifies server\n//     window.onbeforeunload = () => {\n//       try {\n//         socket.emit('leave', { userId: user.id, roomId: rId });\n//       } catch (e) { /* ignore */ }\n//     };\n//   };\n\n//   const leave = () => {\n//     if (pc) {\n//       try { pc.close(); } catch (e) { /* ignore */ }\n//       pc = null;\n//     }\n//     if (roomId) {\n//       socket.emit('leave', { userId: user.id, roomId });\n//     }\n//     setInCall(false);\n//     setPartner(null);\n//     setRoomId(null);\n//     // clear unload handler\n//     window.onbeforeunload = null;\n//   };\n\n//   return (\n//     <div>\n//       <h2>Call</h2>\n//       {partner && <p>Partner: {partner.username}</p>}\n//       <audio ref={remoteAudio} autoPlay />\n//       {!inCall && <p>Waiting to join call...</p>}\n//       {inCall && <button onClick={leave}>Disconnect</button>}\n//     </div>\n//   );\n// }\nimport React, { useEffect, useRef, useState } from 'react';\nimport socket from '../socket';\n\nlet pc;\n\nexport default function Call1({ user }) {\n  const remoteAudio = useRef();\n  const [inCall, setInCall] = useState(false);\n  const [partner, setPartner] = useState(null);\n  const [roomId, setRoomId] = useState(null);\n\n  useEffect(() => {\n    socket.emit('iamonline', { userId: user.id });\n\n    const onMatched = async ({ roomId: rId, partner: p }) => {\n      setPartner(p);\n      setRoomId(rId);\n      await startPeer(rId);\n    };\n\n    const onOffer = async (offer) => {\n      if (!pc) await startPeer(roomId, false);\n      await pc.setRemoteDescription(offer);\n      const answer = await pc.createAnswer();\n      await pc.setLocalDescription(answer);\n      socket.emit('answer', { roomId, answer });\n    };\n\n    const onAnswer = async (answer) => {\n      if (pc) await pc.setRemoteDescription(answer);\n    };\n\n    const onIceCandidate = async (candidate) => {\n      if (pc) await pc.addIceCandidate(candidate);\n    };\n\n    socket.on('matched', onMatched);\n    socket.on('offer', onOffer);\n    socket.on('answer', onAnswer);\n    socket.on('ice-candidate', onIceCandidate);\n\n    return () => {\n      if (pc) pc.close();\n      pc = null;\n      socket.off('matched', onMatched);\n      socket.off('offer', onOffer);\n      socket.off('answer', onAnswer);\n      socket.off('ice-candidate', onIceCandidate);\n      window.onbeforeunload = null;\n    };\n  }, []);\n\n  const startPeer = async (rId, initiator = true) => {\n    pc = new RTCPeerConnection();\n    setInCall(true);\n\n    let stream;\n    try {\n      stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });\n    } catch (err) {\n      console.error('getUserMedia failed', err);\n      setInCall(false);\n      return;\n    }\n\n    stream.getTracks().forEach(track => pc.addTrack(track, stream));\n\n    pc.ontrack = (e) => {\n      if (remoteAudio.current) remoteAudio.current.srcObject = e.streams[0];\n    };\n\n    pc.onicecandidate = (event) => {\n      if (event.candidate) {\n        socket.emit('ice-candidate', { roomId: rId, candidate: event.candidate });\n      }\n    };\n\n    if (initiator) {\n      const offer = await pc.createOffer();\n      await pc.setLocalDescription(offer);\n      socket.emit('offer', { roomId: rId, offer });\n    }\n\n    window.onbeforeunload = () => {\n      socket.emit('leave', { userId: user.id, roomId: rId });\n    };\n  };\n\n  const leave = () => {\n    if (pc) pc.close();\n    pc = null;\n    if (roomId) socket.emit('leave', { userId: user.id, roomId });\n    setInCall(false);\n    setPartner(null);\n    setRoomId(null);\n    window.onbeforeunload = null;\n  };\n\n  return (\n    <div>\n      <h2>Call</h2>\n      {partner && <p>Partner: {partner.username}</p>}\n      <audio ref={remoteAudio} autoPlay />\n      {!inCall && <p>Waiting to join call...</p>}\n      {inCall && <button onClick={leave}>Disconnect</button>}\n    </div>\n  );\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}